/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type MonitoringCheck struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitoringCheckSpec   `json:"spec,omitempty"`
	Status            MonitoringCheckStatus `json:"status,omitempty"`
}

type MonitoringCheckSpecSettingsDnsValidateAdditionalRrs struct {
	// Fail if value matches regex.
	// +optional
	FailIfMatchesRegexp []string `json:"failIfMatchesRegexp,omitempty" tf:"fail_if_matches_regexp"`
	// Fail if value does not match regex.
	// +optional
	FailIfNotMatchesRegexp []string `json:"failIfNotMatchesRegexp,omitempty" tf:"fail_if_not_matches_regexp"`
}

type MonitoringCheckSpecSettingsDnsValidateAnswerRrs struct {
	// Fail if value matches regex.
	// +optional
	FailIfMatchesRegexp []string `json:"failIfMatchesRegexp,omitempty" tf:"fail_if_matches_regexp"`
	// Fail if value does not match regex.
	// +optional
	FailIfNotMatchesRegexp []string `json:"failIfNotMatchesRegexp,omitempty" tf:"fail_if_not_matches_regexp"`
}

type MonitoringCheckSpecSettingsDnsValidateAuthorityRrs struct {
	// Fail if value matches regex.
	// +optional
	FailIfMatchesRegexp []string `json:"failIfMatchesRegexp,omitempty" tf:"fail_if_matches_regexp"`
	// Fail if value does not match regex.
	// +optional
	FailIfNotMatchesRegexp []string `json:"failIfNotMatchesRegexp,omitempty" tf:"fail_if_not_matches_regexp"`
}

type MonitoringCheckSpecSettingsDns struct {
	// Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
	// +optional
	IpVersion *string `json:"ipVersion,omitempty" tf:"ip_version"`
	// Port to target.
	// +optional
	Port *int64 `json:"port,omitempty" tf:"port"`
	// `TCP` or `UDP`.
	// +optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol"`
	// One of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`.
	// +optional
	RecordType *string `json:"recordType,omitempty" tf:"record_type"`
	// DNS server address to target.
	// +optional
	Server *string `json:"server,omitempty" tf:"server"`
	// Source IP address.
	// +optional
	SourceIPAddress *string `json:"sourceIPAddress,omitempty" tf:"source_ip_address"`
	// List of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.
	// +optional
	ValidRCodes []string `json:"validRCodes,omitempty" tf:"valid_r_codes"`
	// Validate additional matches.
	// +optional
	ValidateAdditionalRrs []MonitoringCheckSpecSettingsDnsValidateAdditionalRrs `json:"validateAdditionalRrs,omitempty" tf:"validate_additional_rrs"`
	// Validate response answer.
	// +optional
	ValidateAnswerRrs *MonitoringCheckSpecSettingsDnsValidateAnswerRrs `json:"validateAnswerRrs,omitempty" tf:"validate_answer_rrs"`
	// Validate response authority.
	// +optional
	ValidateAuthorityRrs *MonitoringCheckSpecSettingsDnsValidateAuthorityRrs `json:"validateAuthorityRrs,omitempty" tf:"validate_authority_rrs"`
}

type MonitoringCheckSpecSettingsHttpBasicAuth struct {
	// Basic auth password.
	Password *string `json:"password" tf:"password"`
	// Basic auth username.
	Username *string `json:"username" tf:"username"`
}

type MonitoringCheckSpecSettingsHttpFailIfHeaderMatchesRegexp struct {
	// Allow header to be missing from responses.
	// +optional
	AllowMissing *bool `json:"allowMissing,omitempty" tf:"allow_missing"`
	// Header name.
	Header *string `json:"header" tf:"header"`
	// Regex that header value should match.
	Regexp *string `json:"regexp" tf:"regexp"`
}

type MonitoringCheckSpecSettingsHttpFailIfHeaderNotMatchesRegexp struct {
	// Allow header to be missing from responses.
	// +optional
	AllowMissing *bool `json:"allowMissing,omitempty" tf:"allow_missing"`
	// Header name.
	Header *string `json:"header" tf:"header"`
	// Regex that header value should match.
	Regexp *string `json:"regexp" tf:"regexp"`
}

type MonitoringCheckSpecSettingsHttpTlsConfig struct {
	// CA certificate in PEM format.
	// +optional
	CaCert *string `json:"caCert,omitempty" tf:"ca_cert"`
	// Client certificate in PEM format.
	// +optional
	ClientCert *string `json:"clientCert,omitempty" tf:"client_cert"`
	// Client key in PEM format.
	// +optional
	ClientKey *string `json:"-" sensitive:"true" tf:"client_key"`
	// Disable target certificate validation.
	// +optional
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty" tf:"insecure_skip_verify"`
	// Used to verify the hostname for the targets.
	// +optional
	ServerName *string `json:"serverName,omitempty" tf:"server_name"`
}

type MonitoringCheckSpecSettingsHttp struct {
	// Basic auth settings.
	// +optional
	BasicAuth *MonitoringCheckSpecSettingsHttpBasicAuth `json:"basicAuth,omitempty" tf:"basic_auth"`
	// Token for use with bearer authorization header.
	// +optional
	BearerToken *string `json:"bearerToken,omitempty" tf:"bearer_token"`
	// The body of the HTTP request used in probe.
	// +optional
	Body *string `json:"body,omitempty" tf:"body"`
	// The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
	// +optional
	CacheBustingQueryParamName *string `json:"cacheBustingQueryParamName,omitempty" tf:"cache_busting_query_param_name"`
	// List of regexes. If any match the response body, the check will fail.
	// +optional
	FailIfBodyMatchesRegexp []string `json:"failIfBodyMatchesRegexp,omitempty" tf:"fail_if_body_matches_regexp"`
	// List of regexes. If any do not match the response body, the check will fail.
	// +optional
	FailIfBodyNotMatchesRegexp []string `json:"failIfBodyNotMatchesRegexp,omitempty" tf:"fail_if_body_not_matches_regexp"`
	// Check fails if headers match.
	// +optional
	FailIfHeaderMatchesRegexp []MonitoringCheckSpecSettingsHttpFailIfHeaderMatchesRegexp `json:"failIfHeaderMatchesRegexp,omitempty" tf:"fail_if_header_matches_regexp"`
	// Check fails if headers do not match.
	// +optional
	FailIfHeaderNotMatchesRegexp []MonitoringCheckSpecSettingsHttpFailIfHeaderNotMatchesRegexp `json:"failIfHeaderNotMatchesRegexp,omitempty" tf:"fail_if_header_not_matches_regexp"`
	// Fail if SSL is not present.
	// +optional
	FailIfNotSsl *bool `json:"failIfNotSsl,omitempty" tf:"fail_if_not_ssl"`
	// Fail if SSL is present.
	// +optional
	FailIfSsl *bool `json:"failIfSsl,omitempty" tf:"fail_if_ssl"`
	// The HTTP headers set for the probe.
	// +optional
	Headers []string `json:"headers,omitempty" tf:"headers"`
	// Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
	// +optional
	IpVersion *string `json:"ipVersion,omitempty" tf:"ip_version"`
	// Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE`
	// +optional
	Method *string `json:"method,omitempty" tf:"method"`
	// Do not follow redirects.
	// +optional
	NoFollowRedirects *bool `json:"noFollowRedirects,omitempty" tf:"no_follow_redirects"`
	// Proxy URL.
	// +optional
	ProxyURL *string `json:"proxyURL,omitempty" tf:"proxy_url"`
	// TLS config.
	// +optional
	TlsConfig *MonitoringCheckSpecSettingsHttpTlsConfig `json:"tlsConfig,omitempty" tf:"tls_config"`
	// List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2`
	// +optional
	ValidHTTPVersions []string `json:"validHTTPVersions,omitempty" tf:"valid_http_versions"`
	// Accepted status codes. If unset, defaults to 2xx.
	// +optional
	ValidStatusCodes []int64 `json:"validStatusCodes,omitempty" tf:"valid_status_codes"`
}

type MonitoringCheckSpecSettingsPing struct {
	// Set the DF-bit in the IP-header. Only works with ipV4.
	// +optional
	DontFragment *bool `json:"dontFragment,omitempty" tf:"dont_fragment"`
	// Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
	// +optional
	IpVersion *string `json:"ipVersion,omitempty" tf:"ip_version"`
	// Payload size.
	// +optional
	PayloadSize *int64 `json:"payloadSize,omitempty" tf:"payload_size"`
	// Source IP address.
	// +optional
	SourceIPAddress *string `json:"sourceIPAddress,omitempty" tf:"source_ip_address"`
}

type MonitoringCheckSpecSettingsTcpQueryResponse struct {
	// Response to expect.
	Expect *string `json:"expect" tf:"expect"`
	// Data to send.
	Send *string `json:"send" tf:"send"`
	// Upgrade TCP connection to TLS.
	// +optional
	StartTls *bool `json:"startTls,omitempty" tf:"start_tls"`
}

type MonitoringCheckSpecSettingsTcpTlsConfig struct {
	// CA certificate in PEM format.
	// +optional
	CaCert *string `json:"caCert,omitempty" tf:"ca_cert"`
	// Client certificate in PEM format.
	// +optional
	ClientCert *string `json:"clientCert,omitempty" tf:"client_cert"`
	// Client key in PEM format.
	// +optional
	ClientKey *string `json:"-" sensitive:"true" tf:"client_key"`
	// Disable target certificate validation.
	// +optional
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty" tf:"insecure_skip_verify"`
	// Used to verify the hostname for the targets.
	// +optional
	ServerName *string `json:"serverName,omitempty" tf:"server_name"`
}

type MonitoringCheckSpecSettingsTcp struct {
	// Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available.
	// +optional
	IpVersion *string `json:"ipVersion,omitempty" tf:"ip_version"`
	// The query sent in the TCP probe and the expected associated response.
	// +optional
	QueryResponse []MonitoringCheckSpecSettingsTcpQueryResponse `json:"queryResponse,omitempty" tf:"query_response"`
	// Source IP address.
	// +optional
	SourceIPAddress *string `json:"sourceIPAddress,omitempty" tf:"source_ip_address"`
	// Whether or not TLS is used when the connection is initiated.
	// +optional
	Tls *bool `json:"tls,omitempty" tf:"tls"`
	// TLS config.
	// +optional
	TlsConfig *MonitoringCheckSpecSettingsTcpTlsConfig `json:"tlsConfig,omitempty" tf:"tls_config"`
}

type MonitoringCheckSpecSettings struct {
	// Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
	// +optional
	Dns *MonitoringCheckSpecSettingsDns `json:"dns,omitempty" tf:"dns"`
	// Settings for HTTP check. The target must be a URL (http or https).
	// +optional
	Http *MonitoringCheckSpecSettingsHttp `json:"http,omitempty" tf:"http"`
	// Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
	// +optional
	Ping *MonitoringCheckSpecSettingsPing `json:"ping,omitempty" tf:"ping"`
	// Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
	// +optional
	Tcp *MonitoringCheckSpecSettingsTcp `json:"tcp,omitempty" tf:"tcp"`
}

type MonitoringCheckSpec struct {
	State *MonitoringCheckSpecResource `json:"state,omitempty" tf:"-"`

	Resource MonitoringCheckSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	SecretRef *core.LocalObjectReference `json:"secretRef,omitempty" tf:"-"`
}

type MonitoringCheckSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Can be set to `none`, `low`, `medium`, or `high` to correspond to the check [alert levels](https://grafana.com/docs/grafana-cloud/synthetic-monitoring/synthetic-monitoring-alerting/).
	// +optional
	AlertSensitivity *string `json:"alertSensitivity,omitempty" tf:"alert_sensitivity"`
	// Metrics are reduced by default. Set this to `false` if you'd like to publish all metrics. We maintain a [full list of metrics](https://github.com/grafana/synthetic-monitoring-agent/tree/main/internal/scraper/testdata) collected for each.
	// +optional
	BasicMetricsOnly *bool `json:"basicMetricsOnly,omitempty" tf:"basic_metrics_only"`
	// Whether to enable the check.
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// How often the check runs in milliseconds (the value is not truly a "frequency" but a "period"). The minimum acceptable value is 1 second (1000 ms), and the maximum is 120 seconds (120000 ms).
	// +optional
	Frequency *int64 `json:"frequency,omitempty" tf:"frequency"`
	// Name used for job label.
	Job *string `json:"job" tf:"job"`
	// Custom labels to be included with collected metrics and logs. The maximum number of labels that can be specified per check is 5. These are applied, along with the probe-specific labels, to the outgoing metrics. The names and values of the labels cannot be empty, and the maximum length is 32 bytes.
	// +optional
	Labels *map[string]string `json:"labels,omitempty" tf:"labels"`
	// List of probe location IDs where this target will be checked from.
	Probes []int64 `json:"probes" tf:"probes"`
	// Check settings.
	Settings *MonitoringCheckSpecSettings `json:"settings" tf:"settings"`
	// Hostname to ping.
	Target *string `json:"target" tf:"target"`
	// The tenant ID of the check.
	// +optional
	TenantID *int64 `json:"tenantID,omitempty" tf:"tenant_id"`
	// Specifies the maximum running time for the check in milliseconds. The minimum acceptable value is 1 second (1000 ms), and the maximum 10 seconds (10000 ms).
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
}

type MonitoringCheckStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// MonitoringCheckList is a list of MonitoringChecks
type MonitoringCheckList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of MonitoringCheck CRD objects
	Items []MonitoringCheck `json:"items,omitempty"`
}
